(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{570:function(v,_,t){"use strict";t.r(_);var a=t(5),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("In software engineering, a microservice architecture is an architectural pattern that arranges an application as a collection of loosely coupled, fine-grained services, communicating through lightweight protocols. One of its goals is to enable teams to develop and deploy their services independently. --Wikipedia")])]),v._v(" "),t("p",[v._v("在开聊微服务之前，需要先介绍下单体应用。如果不知道单体应用的痛，那也不会深刻理解微服务的价值。")]),v._v(" "),t("h3",{attrs:{id:"单体应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单体应用"}},[v._v("#")]),v._v(" 单体应用")]),v._v(" "),t("p",[v._v("早些年，各大互联网公司的应用技术栈大致可分为LAMP（Linux + Apache + MySQL + PHP）和MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。无论是LAMP还是MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。")]),v._v(" "),t("p",[v._v("以MVC架构为例，业务通常是通过部署一个WAR包到Tomcat中，然后启动Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。")]),v._v(" "),t("p",[v._v("然而随着业务规模的不断扩大，团队开发人员的不断扩张，单体应用架构就会开始出现以下几个方面的问题。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("部署效率低下。以我实际参与的项目为例，当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要10分钟以上。这也经常被新加入的同学吐槽说，部署测试一次的时间，都可以去楼下喝杯咖啡了。")])]),v._v(" "),t("li",[t("p",[v._v("团队协作开发成本高。以我的经验，早期在团队开发人员只有两三个人的时候，协作修改代码，最后合并到同一个master分支，然后打包部署，尚且可控。但是一旦团队人员扩张，超过5人修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高。")])]),v._v(" "),t("li",[t("p",[v._v("系统高可用性差。因为所有的功能开发最后都部署到同一个WAR包里，运行在同一个Tomcat进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个WAR包中部署的功能。比如我经常遇到的一个问题，某段代码不断在内存中创建大对象，并且没有回收，部署到线上运行一段时间后，就会造成JVM内存泄露，异常退出，那么部署在同一个JVM进程中的所有服务都不可用，后果十分严重。")])]),v._v(" "),t("li",[t("p",[v._v("线上发布变慢。特别是对于Java应用来说，一旦代码膨胀，服务启动的时间就会变长，有些甚至超过10分钟以上，如果机器规模超过100台以上，假设每次发布的步长为10%，单次发布需要就需要100分钟之久。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成本。")])])]),v._v(" "),t("p",[v._v("想要解决上面这些问题，服务化的思想也就应运而生。")]),v._v(" "),t("h3",{attrs:{id:"什么是服务化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是服务化"}},[v._v("#")]),v._v(" 什么是服务化？")]),v._v(" "),t("p",[v._v("用通俗的话来讲，服务化就是把传统的单机应用中通过JAR包依赖产生的本地方法调用，改造成通过RPC接口产生的远程方法调用。一般在编写业务代码时，对于一些通用的业务逻辑，我会尽力把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。")]),v._v(" "),t("p",[v._v("以微博系统为例，微博既包含了内容模块，也包含了消息模块和用户模块等。其中消息模块依赖内容模块，消息模块和内容模块又都依赖用户模块。当这三个模块的代码耦合在一起，应用启动时，需要同时去加载每个模块的代码并连接对应的资源。一旦任何模块的代码出现bug，或者依赖的资源出现问题，整个单体应用都会受到影响。")]),v._v(" "),t("p",[v._v("为此，首先可以把用户模块从单体应用中拆分出来，独立成一个服务部署，以RPC接口的形式对外提供服务。微博和消息模块调用用户接口，就从进程内的调用变成远程RPC调用。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。进一步的可以再把消息模块也拆分出来作为独立的模块，交由专门的团队来开发和维护。")]),v._v(" "),t("p",[v._v("可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。")]),v._v(" "),t("h3",{attrs:{id:"什么是微服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是微服务"}},[v._v("#")]),v._v(" 什么是微服务？")]),v._v(" "),t("p",[v._v("从2014年开始，得益于以Docker为代表的容器化技术的成熟以及DevOps文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。")]),v._v(" "),t("p",[v._v("那么微服务相比于服务化又有什么不同呢？可以总结为以下四点：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("服务拆分粒度更细。微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。")])]),v._v(" "),t("li",[t("p",[v._v("服务独立部署。每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个Docker实例，每个Docker实例可以部署一个微服务的代码。")])]),v._v(" "),t("li",[t("p",[v._v("服务独立维护。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。")])]),v._v(" "),t("li",[t("p",[v._v("服务治理能力要求高。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。")])])]),v._v(" "),t("p",[v._v("继续以前面举的微博系统为例，可以进一步对内容模块的功能进行拆分，比如内容模块又包含了feed模块、评论模块和个人页模块。通过微服务化，将这三个模块变成三个独立的服务，每个服务依赖各自的资源，并独立部署在不同的服务池中，可以由不同的开发人员进行维护。当评论服务需求变更时，只需要修改评论业务相关的代码，并独立上线发布；而feed服务和个人页服务不需要变更，也不会受到发布可能带来的变更影响。")]),v._v(" "),t("p",[v._v("由此可见，微服务化给服务的发布和部署，以及服务的保障带来了诸多好处。")]),v._v(" "),t("h3",{attrs:{id:"什么时候进行服务化拆分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候进行服务化拆分"}},[v._v("#")]),v._v(" 什么时候进行服务化拆分？")]),v._v(" "),t("p",[v._v("项目第一阶段的主要目标是快速开发和验证想法，证明产品思路是否可行。这个阶段功能设计一般不会太复杂，开发采取快速迭代的方式，架构也不适合过度设计。所以将所有功能打包部署在一起，集中地进行开发、测试和运维，对于项目起步阶段，是最高效也是最节省成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。")]),v._v(" "),t("p",[v._v("比如做一个社交App，初期为了快速上线，验证可行性，可以只开发首页信息流、评论等基本功能。产品上线后，经过一段时间的运营，用户开始逐步增多，可行性验证通过，下一阶段就需要进一步增加更多的新特性来吸引更多的目标用户，比如再给这个社交App添加个人主页显示、消息通知等功能。")]),v._v(" "),t("p",[v._v("一般情况下，这个时候就需要大规模地扩张开发人员，以支撑多个功能的开发。如果这个时候继续采用单体应用架构，多个功能模块混杂在一起开发、测试和部署的话，就会导致不同功能之间相互影响，一次打包部署需要所有的功能都测试OK才能上线。")]),v._v(" "),t("p",[v._v("不仅如此，多个功能模块混部在一起，对线上服务的稳定性也是个巨大的挑战。比如A开发的一个功能由于代码编写考虑不够全面，上线后产生了内存泄漏，运行一段时间后进程异常退出，那么部署在这个服务池中的所有功能都不可访问。一个经典的案例就是，曾经有一个视频App，因为短时间内某个付费视频访问量巨大，超过了服务器的承载能力，造成了这个视频无法访问。不幸的是，这个网站付费视频和免费视频的服务部署在一起，也波及了免费视频，几乎全站崩溃。")]),v._v(" "),t("p",[v._v("一旦单体应用同时进行开发的人员超过10人，就会遇到上面的问题，这个时候就该考虑进行服务化拆分了。")]),v._v(" "),t("h3",{attrs:{id:"服务化拆分的两种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务化拆分的两种方式"}},[v._v("#")]),v._v(" 服务化拆分的两种方式")]),v._v(" "),t("p",[v._v("那么服务化拆分具体该如何实施呢？一个最有效的手段就是将不同的功能模块服务化，独立部署和运维。以前面提到的社交App为例，你可以认为首页信息流是一个服务，评论是一个服务，消息通知是一个服务，个人主页也是一个服务。")]),v._v(" "),t("p",[v._v("这种服务化拆分方式是纵向拆分，是从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。")]),v._v(" "),t("p",[v._v("还有一种服务化拆分方式是横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。")]),v._v(" "),t("p",[v._v("继续以前面提到的社交App举例，无论是首页信息流、评论、消息箱还是个人主页，都需要显示用户的昵称。假如用户的昵称功能有产品需求的变更，你需要上线几乎所有的服务，这个成本就有点高了。显而易见，如果我把用户的昵称功能单独部署成一个独立的服务，那么有什么变更我只需要上线这个服务即可，其他服务不受影响，开发和上线成本就大大降低了。")]),v._v(" "),t("h3",{attrs:{id:"服务化拆分的前置条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务化拆分的前置条件"}},[v._v("#")]),v._v(" 服务化拆分的前置条件")]),v._v(" "),t("p",[v._v("一般情况下，业务系统引入新技术就必然会带来架构的复杂度提升，在具体决策前，你先要认识到新架构会带来哪些新的问题，这些问题你和你的团队是否能够解决？如何解决？是自己投入人力建设，还是采用业界开源方案？")]),v._v(" "),t("p",[v._v("下面几个问题，是从单体应用迁移到微服务架构时必将面临也必须解决的。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("服务如何定义。对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。对于微服务来说，每个服务都运行在各自的进程之中，应该以何种形式向外界传达自己的信息呢？答案就是接口，无论采用哪种通讯协议，是HTTP还是RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值。")])]),v._v(" "),t("li",[t("p",[v._v("服务如何发布和订阅。单体应用由于部署在同一个WAR包里，接口之间的调用属于进程内的调用。而拆分为微服务独立部署后，服务提供者该如何对外暴露自己的地址，服务调用者该如何查询所需要调用的服务的地址呢？这个时候你就需要一个类似登记处的地方，能够记录每个服务提供者的地址以供服务调用者查询，在微服务架构里，这个地方就是注册中心。")])]),v._v(" "),t("li",[t("p",[v._v("服务如何监控。通常对于一个服务，我们最关心的是QPS（调用量）、AvgTime（平均耗时）以及P999（99.9%的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。")])]),v._v(" "),t("li",[t("p",[v._v("服务如何治理。可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。")])]),v._v(" "),t("li",[t("p",[v._v("故障如何定位。在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);